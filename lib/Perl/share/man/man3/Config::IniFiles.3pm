.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::IniFiles 3"
.TH Config::IniFiles 3 "2015-06-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::IniFiles \- A module for reading .ini\-style configuration files.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use Config::IniFiles;
\&  my $cfg = Config::IniFiles\->new( \-file => "/path/configfile.ini" );
\&  print "The value is " . $cfg\->val( \*(AqSection\*(Aq, \*(AqParameter\*(Aq ) . "."
\&    if $cfg\->val( \*(AqSection\*(Aq, \*(AqParameter\*(Aq );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Config::IniFiles provides a way to have readable configuration files outside
your Perl script. Configurations can be imported (inherited, stacked,...),
sections can be grouped, and settings can be accessed from a tied hash.
.SH "FILE FORMAT"
.IX Header "FILE FORMAT"
\&\s-1INI\s0 files consist of a number of sections, each preceded with the
section name in square brackets, followed by parameter names and
their values.
.PP
.Vb 2
\&  [a section]
\&  Parameter=Value
\&
\&  [section 2]
\&  AnotherParameter=Some value
\&  Setting=Something else
\&  Parameter=Different scope than the one in the first section
.Ve
.PP
The first non-blank character of the line indicating a section must
be a left bracket and the last non-blank character of a line indicating
a section must be a right bracket. The characters making up the section
name can be any symbols at all. However section names must be unique.
.PP
Parameters are specified in each section as Name=Value.  Any spaces
around the equals sign will be ignored, and the value extends to the
end of the line (including any whitespace at the end of the line.
Parameter names are localized to the namespace of the section, but must
be unique within a section.
.PP
Both the hash mark (#) and the semicolon (;) are comment characters.
by default (this can be changed by configuration). Lines that begin with
either of these characters will be ignored. Any amount of whitespace may
precede the comment character.
.PP
Multi-line or multi-valued parameters may also be defined ala \s-1UNIX
\&\s0\*(L"here document\*(R" syntax:
.PP
.Vb 4
\&  Parameter=<<EOT
\&  value/line 1
\&  value/line 2
\&  EOT
.Ve
.PP
You may use any string you want in place of \*(L"\s-1EOT\*(R".\s0 Note that whatever
follows the \*(L"<<\*(R" and what appears at the end of the text \s-1MUST\s0 match
exactly, including any trailing whitespace.
.PP
Alternately, as a configuration option (default is off), continuation
lines can be allowed:
.PP
.Vb 4
\&  [Section]
\&  Parameter=this parameter \e
\&    spreads across \e
\&    a few lines
.Ve
.SH "USAGE \*(-- Object Interface"
.IX Header "USAGE Object Interface"
Get a new Config::IniFiles object with the \fInew\fR method:
.PP
.Vb 2
\&  $cfg = Config::IniFiles\->new( \-file => "/path/config_file.ini" );
\&  $cfg = new Config::IniFiles \-file => "/path/config_file.ini";
.Ve
.PP
Optional named parameters may be specified after the configuration
file name. See the \fInew\fR in the \fB\s-1METHODS\s0\fR section, below.
.PP
Values from the config file are fetched with the val method:
.PP
.Vb 1
\&  $value = $cfg\->val(\*(AqSection\*(Aq, \*(AqParameter\*(Aq);
.Ve
.PP
If you want a multi\-line/value field returned as an array, just
specify an array as the receiver:
.PP
.Vb 1
\&  @values = $cfg\->val(\*(AqSection\*(Aq, \*(AqParameter\*(Aq);
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "new ( [\-option=>value ...] )"
.IX Subsection "new ( [-option=>value ...] )"
Returns a new configuration object (or \*(L"undef\*(R" if the configuration
file has an error, in which case check the global \f(CW@Config::IniFiles::errors\fR
array for reasons why). One Config::IniFiles object is required per configuration
file. The following named parameters are available:
.IP "\fI\-file\fR  filename" 10
.IX Item "-file filename"
Specifies a file to load the parameters from. This 'file' may actually be
any of the following things:
.Sp
.Vb 1
\&  1) the pathname of a file
\&
\&    $cfg = Config::IniFiles\->new( \-file => "/path/to/config_file.ini" );
\&
\&  2) a simple filehandle
\&
\&    $cfg = Config::IniFiles\->new( \-file => STDIN );
\&
\&  3) a filehandle glob
\&
\&    open( CONFIG, "/path/to/config_file.ini" );
\&    $cfg = Config::IniFiles\->new( \-file => *CONFIG );
\&
\&  4) a reference to a glob
\&
\&    open( CONFIG, "/path/to/config_file.ini" );
\&    $cfg = Config::IniFiles\->new( \-file => \e*CONFIG );
\&
\&  5) an IO::File object
\&
\&    $io = IO::File\->new( "/path/to/config_file.ini" );
\&    $cfg = Config::IniFiles\->new( \-file => $io );
\&
\&  or
\&
\&    open my $fh, \*(Aq<\*(Aq, "/path/to/config_file.ini" or die $!;
\&    $cfg = Config::IniFiles\->new( \-file => $fh );
\&
\&  6) A reference to a scalar (requires newer versions of IO::Scalar)
\&
\&    $ini_file_contents = <<EOT
\&    [section name]
\&    Parameter=A value
\&    Setting=Another value
\&    EOT
\&
\&    $cfg = Config::IniFiles\->new( \-file => \e$ini_file_contents );
.Ve
.Sp
If this option is not specified, (i.e. you are creating a config file from scratch)
you must specify a target file using SetFileName in order to save the parameters.
.IP "\fI\-default\fR section" 10
.IX Item "-default section"
Specifies a section to be used for default values. For example, in the
following configuration file, if you look up the \*(L"permissions\*(R" parameter
in the \*(L"joe\*(R" section, there is none.
.Sp
.Vb 2
\&   [all]
\&   permissions=Nothing
\&
\&   [jane]
\&   name=Jane
\&   permissions=Open files
\&
\&   [joe]
\&   name=Joseph
.Ve
.Sp
If you create your Config::IniFiles object with a default section of \*(L"all\*(R" like this:
.Sp
.Vb 1
\&   $cfg = Config::IniFiles\->new( \-file => "file.ini", \-default => "all" );
.Ve
.Sp
Then requsting a value for a \*(L"permissions\*(R" in the [joe] section will
check for a value from [all] before returning undef.
.Sp
.Vb 1
\&   $permissions = $cfg\->val( "joe", "permissions");   // returns "Nothing"
.Ve
.IP "\fI\-fallback\fR section" 10
.IX Item "-fallback section"
Specifies a section to be used for parameters outside a section. Default is none.
Without \-fallback specified (which is the default), reading a configuration file
which has a parameter outside a section will fail. With this set to, say,
\&\*(L"\s-1GENERAL\*(R",\s0 this configuration:
.Sp
.Vb 1
\&   wrong=wronger
\&
\&   [joe]
\&   name=Joseph
.Ve
.Sp
will be assumed as:
.Sp
.Vb 2
\&   [GENERAL]
\&   wrong=wronger
\&
\&   [joe]
\&   name=Joseph
.Ve
.Sp
Note that Config::IniFiles will also omit the fallback section header when
outputing such configuration.
.IP "\fI\-nocase\fR 0|1" 10
.IX Item "-nocase 0|1"
Set \-nocase => 1 to handle the config file in a case-insensitive
manner (case in values is preserved, however).  By default, config
files are case-sensitive (i.e., a section named 'Test' is not the same
as a section named 'test').  Note that there is an added overhead for
turning off case sensitivity.
.IP "\fI\-import\fR object" 10
.IX Item "-import object"
This allows you to import or inherit existing setting from another
Config::IniFiles object. When importing settings from another object,
sections with the same name will be merged and parameters that are
defined in both the imported object and the \fI\-file\fR will take the
value of given in the \fI\-file\fR.
.Sp
If a \fI\-default\fR section is also given on this call, and it does not
coincide with the default of the imported object, the new default
section will be used instead. If no \fI\-default\fR section is given,
then the default of the imported object will be used.
.IP "\fI\-allowcontinue\fR 0|1" 10
.IX Item "-allowcontinue 0|1"
Set \-allowcontinue => 1 to enable continuation lines in the config file.
i.e. if a line ends with a backslash \f(CW\*(C`\e\*(C'\fR, then the following line is
appended to the parameter value, dropping the backslash and the newline
character(s).
.Sp
Default behavior is to keep a trailing backslash \f(CW\*(C`\e\*(C'\fR as a parameter
value. Note that continuation cannot be mixed with the \*(L"here\*(R" value
syntax.
.IP "\fI\-allowempty\fR 0|1" 10
.IX Item "-allowempty 0|1"
If set to 1, then empty files are allowed at ReadConfig
time. If set to 0 (the default), an empty configuration file is considered
an error.
.IP "\fI\-negativedeltas\fR 0|1" 10
.IX Item "-negativedeltas 0|1"
If set to 1 (the default if importing this object from another one),
parses and honors lines of the following form in the configuration
file:
.Sp
.Vb 1
\&  ; [somesection] is deleted
.Ve
.Sp
or
.Sp
.Vb 2
\&  [inthissection]
\&  ; thisparameter is deleted
.Ve
.Sp
If set to 0 (the default if not importing), these comments are treated
like ordinary ones.
.Sp
The WriteConfig1)> form will output such
comments to indicate deleted sections or parameters. This way,
reloading a delta file using the same imported object produces the
same results in memory again. See \*(L" \s-1DELTA FEATURES\*(R"\s0 in \s-1IMPORT \s0 for more
details.
.IP "\fI\-commentchar\fR 'char'" 10
.IX Item "-commentchar 'char'"
The default comment character is \f(CW\*(C`#\*(C'\fR. You may change this by specifying
this option to another character. This can be any character except
alphanumeric characters, square brackets or the \*(L"equal\*(R" sign.
.IP "\fI\-allowedcommentchars\fR 'chars'" 10
.IX Item "-allowedcommentchars 'chars'"
Allowed default comment characters are \f(CW\*(C`#\*(C'\fR and \f(CW\*(C`;\*(C'\fR. By specifying this
option you may change the range of characters that are used to denote a
comment line to include any set of characters
.Sp
Note: that the character specified by \fB\-commentchar\fR (see above) is
\&\fIalways\fR part of the allowed comment characters.
.Sp
Note 2: The given string is evaluated as a regular expression character
class, so '\e' must be escaped if you wish to use it.
.IP "\fI\-reloadwarn\fR 0|1" 10
.IX Item "-reloadwarn 0|1"
Set \-reloadwarn => 1 to enable a warning message (output to \s-1STDERR\s0)
whenever the config file is reloaded.  The reload message is of the
form:
.Sp
.Vb 1
\&  PID <PID> reloading config file <file> at YYYY.MM.DD HH:MM:SS
.Ve
.Sp
Default behavior is to not warn (i.e. \-reloadwarn => 0).
.Sp
This is generally only useful when using Config::IniFiles in a server
or daemon application. The application is still responsible for determining
when the object is to be reloaded.
.IP "\fI\-nomultiline\fR 0|1" 10
.IX Item "-nomultiline 0|1"
Set \-nomultiline => 1 to output multi-valued parameter as:
.Sp
.Vb 2
\& param=value1
\& param=value2
.Ve
.Sp
instead of the default:
.Sp
.Vb 4
\& param=<<EOT
\& value1
\& value2
\& EOT
.Ve
.Sp
As the later might not be compatible with all applications.
.IP "\fI\-handle_trailing_comment\fR 0|1" 10
.IX Item "-handle_trailing_comment 0|1"
Set \-handle_trailing_comment => 1 to enable support of parameter trailing
comments.
.Sp
For example, if we have a parameter line like this:
.Sp
.Vb 1
\& param1=value1;comment1
.Ve
.Sp
by default, handle_trailing_comment will be set to \fB0\fR, and we will get
\&\fIvalue1;comment1\fR as the value of \fIparam1\fR. If we have
\&\-handle_trailing_comment set to \fB1\fR, then we will get \fIvalue1\fR
as the value for \fIparam1\fR, and \fIcomment1\fR as the trailing comment of
\&\fIparam1\fR.
.Sp
Set and get methods for trailing comments are provided as
\&\*(L"SetParameterTrailingComment\*(R" and \*(L"GetParameterTrailingComment\*(R".
.ie n .SS "val ($section, $parameter [, $default] )"
.el .SS "val ($section, \f(CW$parameter\fP [, \f(CW$default\fP] )"
.IX Subsection "val ($section, $parameter [, $default] )"
Returns the value of the specified parameter (\f(CW$parameter\fR) in section
\&\f(CW$section\fR, returns undef (or \f(CW$default\fR if specified) if no section or
no parameter for the given section exists.
.PP
If you want a multi\-line/value field returned as an array, just
specify an array as the receiver:
.PP
.Vb 1
\&  @values = $cfg\->val(\*(AqSection\*(Aq, \*(AqParameter\*(Aq);
.Ve
.PP
A multi\-line/value field that is returned in a scalar context will be
joined using $/ (input record separator, default is \en) if defined,
otherwise the values will be joined using \en.
.ie n .SS "exists($section, $parameter)"
.el .SS "exists($section, \f(CW$parameter\fP)"
.IX Subsection "exists($section, $parameter)"
True if and only if there exists a section \f(CW$section\fR, with
a parameter \f(CW$parameter\fR inside, not counting default values.
.ie n .SS "push ($section, $parameter, $value, [ $value2, ...])"
.el .SS "push ($section, \f(CW$parameter\fP, \f(CW$value\fP, [ \f(CW$value2\fP, ...])"
.IX Subsection "push ($section, $parameter, $value, [ $value2, ...])"
Pushes new values at the end of existing value(s) of parameter
\&\f(CW$parameter\fR in section \f(CW$section\fR.  See below for methods to write
the new configuration back out to a file.
.PP
You may not set a parameter that didn't exist in the original
configuration file.  \fBpush\fR will return \fIundef\fR if this is
attempted. See \fBnewval\fR below to do this. Otherwise, it returns 1.
.ie n .SS "setval ($section, $parameter, $value, [ $value2, ... ])"
.el .SS "setval ($section, \f(CW$parameter\fP, \f(CW$value\fP, [ \f(CW$value2\fP, ... ])"
.IX Subsection "setval ($section, $parameter, $value, [ $value2, ... ])"
Sets the value of parameter \f(CW$parameter\fR in section \f(CW$section\fR to
\&\f(CW$value\fR (or to a set of values).  See below for methods to write
the new configuration back out to a file.
.PP
You may not set a parameter that didn't exist in the original
configuration file.  \fBsetval\fR will return \fIundef\fR if this is
attempted. See \fBnewval\fR below to do this. Otherwise, it returns 1.
.ie n .SS "newval($section, $parameter, $value [, $value2, ...])"
.el .SS "newval($section, \f(CW$parameter\fP, \f(CW$value\fP [, \f(CW$value2\fP, ...])"
.IX Subsection "newval($section, $parameter, $value [, $value2, ...])"
Assignes a new value, \f(CW$value\fR (or set of values) to the
parameter \f(CW$parameter\fR in section \f(CW$section\fR in the configuration
file.
.ie n .SS "delval($section, $parameter)"
.el .SS "delval($section, \f(CW$parameter\fP)"
.IX Subsection "delval($section, $parameter)"
Deletes the specified parameter from the configuration file
.SS "ReadConfig"
.IX Subsection "ReadConfig"
Forces the configuration file to be re-read. Returns undef if the
file can not be opened, no filename was defined (with the \f(CW\*(C`\-file\*(C'\fR
option) when the object was constructed, or an error occurred while
reading.
.PP
If an error occurs while parsing the \s-1INI\s0 file the \f(CW@Config::IniFiles::errors\fR
array will contain messages that might help you figure out where the
problem is in the file.
.SS "Sections"
.IX Subsection "Sections"
Returns an array containing section names in the configuration file.
If the \fInocase\fR option was turned on when the config object was
created, the section names will be returned in lowercase.
.ie n .SS "SectionExists ( $sect_name )"
.el .SS "SectionExists ( \f(CW$sect_name\fP )"
.IX Subsection "SectionExists ( $sect_name )"
Returns 1 if the specified section exists in the \s-1INI\s0 file, 0 otherwise (undefined if section_name is not defined).
.ie n .SS "AddSection ( $sect_name )"
.el .SS "AddSection ( \f(CW$sect_name\fP )"
.IX Subsection "AddSection ( $sect_name )"
Ensures that the named section exists in the \s-1INI\s0 file. If the section already
exists, nothing is done. In this case, the \*(L"new\*(R" section will possibly contain
data already.
.PP
If you really need to have a new section with no parameters in it, check that
the name that you're adding isn't in the list of sections already.
.ie n .SS "DeleteSection ( $sect_name )"
.el .SS "DeleteSection ( \f(CW$sect_name\fP )"
.IX Subsection "DeleteSection ( $sect_name )"
Completely removes the entire section from the configuration.
.ie n .SS "RenameSection ( $old_section_name, $new_section_name, $include_groupmembers)"
.el .SS "RenameSection ( \f(CW$old_section_name\fP, \f(CW$new_section_name\fP, \f(CW$include_groupmembers\fP)"
.IX Subsection "RenameSection ( $old_section_name, $new_section_name, $include_groupmembers)"
Renames a section if it does not already exists optionally including groupmembers
.ie n .SS "CopySection ( $old_section_name, $new_section_name, $include_groupmembers)"
.el .SS "CopySection ( \f(CW$old_section_name\fP, \f(CW$new_section_name\fP, \f(CW$include_groupmembers\fP)"
.IX Subsection "CopySection ( $old_section_name, $new_section_name, $include_groupmembers)"
Copies one section to another optionally including groupmembers
.SS "Parameters ($sect_name)"
.IX Subsection "Parameters ($sect_name)"
Returns an array containing the parameters contained in the specified
section.
.SS "Groups"
.IX Subsection "Groups"
Returns an array containing the names of available groups.
.PP
Groups are specified in the config file as new sections of the form
.PP
.Vb 1
\&  [GroupName MemberName]
.Ve
.PP
This is useful for building up lists.  Note that parameters within a
\&\*(L"member\*(R" section are referenced normally (i.e., the section name is
still \*(L"Groupname Membername\*(R", including the space) \- the concept of
Groups is to aid people building more complex configuration files.
.ie n .SS "SetGroupMember ( $sect )"
.el .SS "SetGroupMember ( \f(CW$sect\fP )"
.IX Subsection "SetGroupMember ( $sect )"
Makes sure that the specified section is a member of the appropriate group.
.PP
Only intended for use in newval.
.ie n .SS "RemoveGroupMember ( $sect )"
.el .SS "RemoveGroupMember ( \f(CW$sect\fP )"
.IX Subsection "RemoveGroupMember ( $sect )"
Makes sure that the specified section is no longer a member of the
appropriate group. Only intended for use in DeleteSection.
.SS "GroupMembers ($group)"
.IX Subsection "GroupMembers ($group)"
Returns an array containing the members of specified \f(CW$group\fR. Each element
of the array is a section name. For example, given the sections
.PP
.Vb 2
\&  [Group Element 1]
\&  ...
\&
\&  [Group Element 2]
\&  ...
.Ve
.PP
GroupMembers would return (\*(L"Group Element 1\*(R", \*(L"Group Element 2\*(R").
.SS "SetWriteMode ($mode)"
.IX Subsection "SetWriteMode ($mode)"
Sets the mode (permissions) to use when writing the \s-1INI\s0 file.
.PP
\&\f(CW$mode\fR must be a string representation of the octal mode.
.SS "GetWriteMode ($mode)"
.IX Subsection "GetWriteMode ($mode)"
Gets the current mode (permissions) to use when writing the \s-1INI\s0 file.
.PP
\&\f(CW$mode\fR is a string representation of the octal mode.
.ie n .SS "WriteConfig ($filename [, %options])"
.el .SS "WriteConfig ($filename [, \f(CW%options\fP])"
.IX Subsection "WriteConfig ($filename [, %options])"
Writes out a new copy of the configuration file.  A temporary file
is written out and then renamed to the specified filename.  Also see
\&\fB\s-1BUGS\s0\fR below.
.PP
If \f(CW\*(C`\-delta\*(C'\fR is set to a true value in \f(CW%options\fR, and this object was
imported from another (see \*(L"new\*(R"), only the differences between this
object and the imported one will be recorded. Negative deltas will be
encoded into comments, so that a subsequent invocation of \fI\fInew()\fI\fR
with the same imported object produces the same results (see the
\&\fI\-negativedeltas\fR option in \*(L"new\*(R").
.PP
\&\f(CW%options\fR is not required.
.PP
Returns true on success, \f(CW\*(C`undef\*(C'\fR on failure.
.SS "RewriteConfig"
.IX Subsection "RewriteConfig"
Same as WriteConfig, but specifies that the original configuration
file should be rewritten.
.SS "GetFileName"
.IX Subsection "GetFileName"
Returns the filename associated with this \s-1INI\s0 file.
.PP
If no filename has been specified, returns undef.
.SS "SetFileName ($filename)"
.IX Subsection "SetFileName ($filename)"
If you created the Config::IniFiles object without initialising from
a file, or if you just want to change the name of the file to use for
ReadConfig/RewriteConfig from now on, use this method.
.PP
Returns \f(CW$filename\fR if that was a valid name, undef otherwise.
.ie n .SS "$ini\->OutputConfigToFileHandle($fh, $delta)"
.el .SS "\f(CW$ini\fP\->OutputConfigToFileHandle($fh, \f(CW$delta\fP)"
.IX Subsection "$ini->OutputConfigToFileHandle($fh, $delta)"
Writes OutputConfig to the \f(CW$fh\fR filehandle. \f(CW$delta\fR should be set to 1
1 if writing only delta. This is a newer and safer version of
\&\f(CW\*(C`OutputConfig()\*(C'\fR and one is encouraged to use it instead.
.ie n .SS "$ini\->OutputConfig($delta)"
.el .SS "\f(CW$ini\fP\->OutputConfig($delta)"
.IX Subsection "$ini->OutputConfig($delta)"
Writes OutputConfig to \s-1STDOUT.\s0 Use \fIselect()\fR to redirect \s-1STDOUT\s0 to
the output target before calling this function. Optional argument
should be set to 1 if writing only delta. Also see OutputConfigToFileHandle
.ie n .SS "SetSectionComment($section, @comment)"
.el .SS "SetSectionComment($section, \f(CW@comment\fP)"
.IX Subsection "SetSectionComment($section, @comment)"
Sets the comment for section \f(CW$section\fR to the lines contained in \f(CW@comment\fR.
.PP
Each comment line will be prepended with the comment character (default
is \f(CW\*(C`#\*(C'\fR) if it doesn't already have a comment character (ie: if the
line does not start with whitespace followed by an allowed comment
character, default is \f(CW\*(C`#\*(C'\fR and \f(CW\*(C`;\*(C'\fR).
.PP
To clear a section comment, use DeleteSectionComment ($section)
.SS "GetSectionComment ($section)"
.IX Subsection "GetSectionComment ($section)"
Returns a list of lines, being the comment attached to section \f(CW$section\fR. In
scalar context, returns a string containing the lines of the comment separated
by newlines.
.PP
The lines are presented as-is, with whatever comment character was originally
used on that line.
.SS "DeleteSectionComment ($section)"
.IX Subsection "DeleteSectionComment ($section)"
Removes the comment for the specified section.
.ie n .SS "SetParameterComment ($section, $parameter, @comment)"
.el .SS "SetParameterComment ($section, \f(CW$parameter\fP, \f(CW@comment\fP)"
.IX Subsection "SetParameterComment ($section, $parameter, @comment)"
Sets the comment attached to a particular parameter.
.PP
Any line of \f(CW@comment\fR that does not have a comment character will be
prepended with one. See \*(L"SetSectionComment($section, \f(CW@comment\fR)\*(R" above
.ie n .SS "GetParameterComment ($section, $parameter)"
.el .SS "GetParameterComment ($section, \f(CW$parameter\fP)"
.IX Subsection "GetParameterComment ($section, $parameter)"
Gets the comment attached to a parameter. In list context returns all
comments \- in scalar context returns them joined by newlines.
.ie n .SS "DeleteParameterComment ($section, $parmeter)"
.el .SS "DeleteParameterComment ($section, \f(CW$parmeter\fP)"
.IX Subsection "DeleteParameterComment ($section, $parmeter)"
Deletes the comment attached to a parameter.
.ie n .SS "GetParameterEOT ($section, $parameter)"
.el .SS "GetParameterEOT ($section, \f(CW$parameter\fP)"
.IX Subsection "GetParameterEOT ($section, $parameter)"
Accessor method for the \s-1EOT\s0 text (in fact, style) of the specified parameter. If any text is used as an \s-1EOT\s0 mark, this will be returned. If the parameter was not recorded using \s-1HERE\s0 style multiple lines, GetParameterEOT returns undef.
.ie n .SS "$cfg\->SetParameterEOT ($section, $parameter, $EOT)"
.el .SS "\f(CW$cfg\fP\->SetParameterEOT ($section, \f(CW$parameter\fP, \f(CW$EOT\fP)"
.IX Subsection "$cfg->SetParameterEOT ($section, $parameter, $EOT)"
Accessor method for the \s-1EOT\s0 text for the specified parameter. Sets the \s-1HERE\s0 style marker text to the value \f(CW$EOT\fR. Once the \s-1EOT\s0 text is set, that parameter will be saved in \s-1HERE\s0 style.
.PP
To un-set the \s-1EOT\s0 text, use DeleteParameterEOT ($section, \f(CW$parameter\fR).
.ie n .SS "DeleteParameterEOT ($section, $parmeter)"
.el .SS "DeleteParameterEOT ($section, \f(CW$parmeter\fP)"
.IX Subsection "DeleteParameterEOT ($section, $parmeter)"
Removes the \s-1EOT\s0 marker for the given section and parameter.
When writing a configuration file, if no \s-1EOT\s0 marker is defined
then \*(L"\s-1EOT\*(R"\s0 is used.
.ie n .SS "SetParameterTrailingComment ($section, $parameter, $cmt)"
.el .SS "SetParameterTrailingComment ($section, \f(CW$parameter\fP, \f(CW$cmt\fP)"
.IX Subsection "SetParameterTrailingComment ($section, $parameter, $cmt)"
Set the end trailing comment for the given section and parameter.
If there is a old comment for the parameter, it will be
overwritten by the new one.
.PP
If there is a new parameter trailing comment to be added, the
value should be added first.
.ie n .SS "GetParameterTrailingComment ($section, $parameter)"
.el .SS "GetParameterTrailingComment ($section, \f(CW$parameter\fP)"
.IX Subsection "GetParameterTrailingComment ($section, $parameter)"
An accessor method to read the trailing comment after the parameter.
The trailing comment will be returned if there is one. A null string
will be returned if the parameter exists but no comment for it.
otherwise, undef will be returned.
.SS "Delete"
.IX Subsection "Delete"
Deletes the entire configuration file in memory.
.SH "USAGE \*(-- Tied Hash"
.IX Header "USAGE Tied Hash"
.ie n .SS "tie %ini, 'Config::IniFiles', (\-file=>$filename, [\-option=>value ...] )"
.el .SS "tie \f(CW%ini\fP, 'Config::IniFiles', (\-file=>$filename, [\-option=>value ...] )"
.IX Subsection "tie %ini, 'Config::IniFiles', (-file=>$filename, [-option=>value ...] )"
Using \f(CW\*(C`tie\*(C'\fR, you can tie a hash to a \fBConfig::IniFiles\fR object. This creates a new
object which you can access through your hash, so you use this instead of the
\&\fBnew\fR method. This actually creates a hash of hashes to access the values in
the \s-1INI\s0 file. The options you provide through \f(CW\*(C`tie\*(C'\fR are the same as given for
the \fBnew\fR method, above.
.PP
Here's an example:
.PP
.Vb 1
\&  use Config::IniFiles;
\&
\&  my %ini;
\&  tie %ini, \*(AqConfig::IniFiles\*(Aq, ( \-file => "/path/configfile.ini" );
\&
\&  print "We have $ini{Section}{Parameter}." if $ini{Section}{Parameter};
.Ve
.PP
Accessing and using the hash works just like accessing a regular hash and
many of the object methods are made available through the hash interface.
.PP
For those methods that do not coincide with the hash paradigm, you can use
the Perl \f(CW\*(C`tied\*(C'\fR function to get at the underlying object tied to the hash
and call methods on that object. For example, to write the hash out to a new
ini file, you would do something like this:
.PP
.Vb 2
\&  tied( %ini )\->WriteConfig( "/newpath/newconfig.ini" ) ||
\&    die "Could not write settings to new file.";
.Ve
.ie n .SS "$val = $ini{$section}{$parameter}"
.el .SS "\f(CW$val\fP = \f(CW$ini\fP{$section}{$parameter}"
.IX Subsection "$val = $ini{$section}{$parameter}"
Returns the value of \f(CW$parameter\fR in \f(CW$section\fR.
.PP
Multiline values accessed through a hash will be returned
as a list in list context and a concatenated value in scalar
context.
.ie n .SS "$ini{$section}{$parameter} = $value;"
.el .SS "\f(CW$ini\fP{$section}{$parameter} = \f(CW$value\fP;"
.IX Subsection "$ini{$section}{$parameter} = $value;"
Sets the value of \f(CW$parameter\fR in \f(CW$section\fR to \f(CW$value\fR.
.PP
To set a multiline or multiv-alue parameter just assign an
array reference to the hash entry, like this:
.PP
.Vb 1
\& $ini{$section}{$parameter} = [$value1, $value2, ...];
.Ve
.PP
If the parameter did not exist in the original file, it will
be created. However, Perl does not seem to extend autovivification
to tied hashes. That means that if you try to say
.PP
.Vb 1
\&  $ini{new_section}{new_paramters} = $val;
.Ve
.PP
and the section 'new_section' does not exist, then Perl won't
properly create it. In order to work around this you will need
to create a hash reference in that section and then assign the
parameter value. Something like this should do nicely:
.PP
.Vb 2
\&  $ini{new_section} = {};
\&  $ini{new_section}{new_paramters} = $val;
.Ve
.ie n .SS "%hash = %{$ini{$section}}"
.el .SS "\f(CW%hash\fP = %{$ini{$section}}"
.IX Subsection "%hash = %{$ini{$section}}"
Using the tie interface, you can copy whole sections of the
ini file into another hash. Note that this makes a copy of
the entire section. The new hash in no longer tied to the
ini file, In particular, this means \-default and \-nocase
settings will not apply to \f(CW%hash\fR.
.ie n .SS "$ini{$section} = {}; %{$ini{$section}} = %parameters;"
.el .SS "\f(CW$ini\fP{$section} = {}; %{$ini{$section}} = \f(CW%parameters\fP;"
.IX Subsection "$ini{$section} = {}; %{$ini{$section}} = %parameters;"
Through the hash interface, you have the ability to replace
the entire section with a new set of parameters. This call
will fail, however, if the argument passed in \s-1NOT\s0 a hash
reference. You must use both lines, as shown above so that
Perl recognizes the section as a hash reference context
before COPYing over the values from your \f(CW%parameters\fR hash.
.ie n .SS "delete $ini{$section}{$parameter}"
.el .SS "delete \f(CW$ini\fP{$section}{$parameter}"
.IX Subsection "delete $ini{$section}{$parameter}"
When tied to a hash, you can use the Perl \f(CW\*(C`delete\*(C'\fR function
to completely remove a parameter from a section.
.ie n .SS "delete $ini{$section}"
.el .SS "delete \f(CW$ini\fP{$section}"
.IX Subsection "delete $ini{$section}"
The tied interface also allows you to delete an entire
section from the ini file using the Perl \f(CW\*(C`delete\*(C'\fR function.
.ie n .SS "%ini = ();"
.el .SS "\f(CW%ini\fP = ();"
.IX Subsection "%ini = ();"
If you really want to delete \fBall\fR the items in the ini file, this
will do it. Of course, the changes won't be written to the actual
file unless you call \fBRewriteConfig\fR on the object tied to the hash.
.SS "Parameter names"
.IX Subsection "Parameter names"
.ie n .IP "my @keys = keys %{$ini{$section}}" 4
.el .IP "my \f(CW@keys\fR = keys %{$ini{$section}}" 4
.IX Item "my @keys = keys %{$ini{$section}}"
.PD 0
.ie n .IP "while (($k, $v) = each %{$ini{$section}}) {...}" 4
.el .IP "while (($k, \f(CW$v\fR) = each %{$ini{$section}}) {...}" 4
.IX Item "while (($k, $v) = each %{$ini{$section}}) {...}"
.ie n .IP "if( exists %{$ini{$section}}, $parameter ) {...}" 4
.el .IP "if( exists %{$ini{$section}}, \f(CW$parameter\fR ) {...}" 4
.IX Item "if( exists %{$ini{$section}}, $parameter ) {...}"
.PD
.PP
When tied to a hash, you use the Perl \f(CW\*(C`keys\*(C'\fR and \f(CW\*(C`each\*(C'\fR
functions to iteratively list the parameters (\f(CW\*(C`keys\*(C'\fR) or
parameters and their values (\f(CW\*(C`each\*(C'\fR) in a given section.
.PP
You can also use the Perl \f(CW\*(C`exists\*(C'\fR function to see if a
parameter is defined in a given section.
.PP
Note that none of these will return parameter names that
are part of the default section (if set), although accessing
an unknown parameter in the specified section will return a
value from the default section if there is one.
.SS "Section names"
.IX Subsection "Section names"
.ie n .IP "foreach( keys %ini ) {...}" 4
.el .IP "foreach( keys \f(CW%ini\fR ) {...}" 4
.IX Item "foreach( keys %ini ) {...}"
.PD 0
.ie n .IP "while (($k, $v) = each %ini) {...}" 4
.el .IP "while (($k, \f(CW$v\fR) = each \f(CW%ini\fR) {...}" 4
.IX Item "while (($k, $v) = each %ini) {...}"
.ie n .IP "if( exists %ini, $section ) {...}" 4
.el .IP "if( exists \f(CW%ini\fR, \f(CW$section\fR ) {...}" 4
.IX Item "if( exists %ini, $section ) {...}"
.PD
.PP
When tied to a hash, you use the Perl \f(CW\*(C`keys\*(C'\fR and \f(CW\*(C`each\*(C'\fR
functions to iteratively list the sections in the ini file.
.PP
You can also use the Perl \f(CW\*(C`exists\*(C'\fR function to see if a
section is defined in the file.
.SH "IMPORT / DELTA FEATURES"
.IX Header "IMPORT / DELTA FEATURES"
The \fI\-import\fR option to \*(L"new\*(R" allows one to stack one
\&\fIConfig::IniFiles\fR object on top of another (which might be itself
stacked in turn and so on recursively, but this is beyond the
point). The effect, as briefly explained in \*(L"new\*(R", is that the
fields appearing in the composite object will be a superposition of
those coming from the ``original'' one and the lines coming from the
file, the latter taking precedence. For example, let's say that
\&\f(CW$master\fR and \f(CW\*(C`overlay\*(C'\fR were created like this:
.PP
.Vb 3
\&   my $master  = Config::IniFiles\->new(\-file => "master.ini");
\&   my $overlay = Config::IniFiles\->new(\-file => "overlay.ini",
\&            \-import => $master);
.Ve
.PP
If the contents of \f(CW\*(C`master.ini\*(C'\fR and \f(CW\*(C`overlay.ini\*(C'\fR are respectively
.PP
.Vb 4
\&   ; master.ini
\&   [section1]
\&   arg0=unchanged from master.ini
\&   arg1=val1
\&
\&   [section2]
\&   arg2=val2
.Ve
.PP
and
.PP
.Vb 3
\&   ; overlay.ini
\&   [section1]
\&   arg1=overriden
.Ve
.PP
Then \f(CW\*(C`$overlay\->val("section1", "arg1")\*(C'\fR is \*(L"overriden\*(R", while
\&\f(CW\*(C`$overlay\->val("section1", "arg0")\*(C'\fR is \*(L"unchanged from
master.ini\*(R".
.PP
This feature may be used to ship a ``global defaults'' configuration
file for a Perl application, that can be overridden piecewise by a
much shorter, per-site configuration file. Assuming UNIX-style path
names, this would be done like this:
.PP
.Vb 6
\&   my $defaultconfig = Config::IniFiles\->new
\&       (\-file => "/usr/share/myapp/myapp.ini.default");
\&   my $config = Config::IniFiles\->new
\&       (\-file => "/etc/myapp.ini", \-import => $defaultconfig);
\&   # Now use $config and forget about $defaultconfig in the rest of
\&   # the program
.Ve
.PP
Starting with version 2.39, \fIConfig::IniFiles\fR also provides features
to keep the importing / per-site configuration file small, by only
saving those options that were modified by the running program. That
is, if one calls
.PP
.Vb 3
\&   $overlay\->setval("section1", "arg1", "anotherval");
\&   $overlay\->newval("section3", "arg3", "val3");
\&   $overlay\->WriteConfig(\*(Aqoverlay.ini\*(Aq, \-delta=>1);
.Ve
.PP
\&\f(CW\*(C`overlay.ini\*(C'\fR would now contain
.PP
.Vb 3
\&   ; overlay.ini
\&   [section1]
\&   arg1=anotherval
\&
\&   [section3]
\&   arg3=val3
.Ve
.PP
This is called a \fIdelta file\fR (see \*(L"WriteConfig\*(R"). The untouched
[section2] and arg0 do not appear, and the config file is therefore
shorter; while of course, reloading the configuration into \f(CW$master\fR
and \f(CW$overlay\fR, either through \f(CW\*(C`$overlay\->ReadConfig()\*(C'\fR or through
the same code as above (e.g. when application restarts), would yield
exactly the same result had the overlay object been saved in whole to
the file system.
.PP
The only problem with this delta technique is one cannot delete the
default values in the overlay configuration file, only change
them. This is solved by a file format extension, enabled by the
\&\fI\-negativedeltas\fR option to \*(L"new\*(R": if, say, one would delete
parameters like this,
.PP
.Vb 3
\&   $overlay\->DeleteSection("section2");
\&   $overlay\->delval("section1", "arg0");
\&   $overlay\->WriteConfig(\*(Aqoverlay.ini\*(Aq, \-delta=>1);
.Ve
.PP
The \fIoverlay.ini\fR file would now read:
.PP
.Vb 4
\&   ; overlay.ini
\&   [section1]
\&   ; arg0 is deleted
\&   arg1=anotherval
\&
\&   ; [section2] is deleted
\&
\&   [section3]
\&   arg3=val3
.Ve
.PP
Assuming \f(CW$overlay\fR was later re-read with \f(CW\*(C`\-negativedeltas => 1\*(C'\fR,
the parser would interpret the deletion comments to yield the correct
result, that is, [section2] and arg0 would cease to exist in the
\&\f(CW$overlay\fR object.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .SS "@Config::IniFiles::errors"
.el .SS "\f(CW@Config::IniFiles::errors\fP"
.IX Subsection "@Config::IniFiles::errors"
Contains a list of errors encountered while parsing the configuration
file.  If the \fInew\fR method returns \fBundef\fR, check the value of this
to find out what's wrong.  This value is reset each time a config file
is read.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 3
The output from [Re]WriteConfig/OutputConfig might not be as pretty as
it can be.  Comments are tied to whatever was immediately below them.
And case is not preserved for Section and Parameter names if the \-nocase
option was used.
.IP "\(bu" 3
No locking is done by [Re]WriteConfig.  When writing servers, take
care that only the parent ever calls this, and consider making your
own backup.
.SH "Data Structure"
.IX Header "Data Structure"
Note that this is only a reference for the package maintainers \- one of the
upcoming revisions to this package will include a total clean up of the
data structure.
.PP
.Vb 10
\&  $iniconf\->{cf} = "config_file_name"
\&          \->{startup_settings} = \e%orginal_object_parameters
\&          \->{firstload} = 0 OR 1
\&          \->{imported} = $object WHERE $object\->isa("Config::IniFiles")
\&          \->{nocase} = 0
\&          \->{reloadwarn} = 0
\&          \->{sects} = \e@sections
\&          \->{mysects} = \e@sections
\&          \->{sCMT}{$sect} = \e@comment_lines
\&          \->{group}{$group} = \e@group_members
\&          \->{parms}{$sect} = \e@section_parms
\&          \->{myparms}{$sect} = \e@section_parms
\&          \->{EOT}{$sect}{$parm} = "end of text string"
\&          \->{pCMT}{$sect}{$parm} = \e@comment_lines
\&          \->{v}{$sect}{$parm} = $value   OR  \e@values
.Ve
.SH "AUTHOR and ACKNOWLEDGEMENTS"
.IX Header "AUTHOR and ACKNOWLEDGEMENTS"
The original code was written by Scott Hutton.
Then handled for a time by Rich Bowen (thanks!),
and was later managed by Jeremy Wadsack (thanks!),
and now is managed by Shlomi Fish ( <http://www.shlomifish.org/> )
with many contributions from various other people.
.PP
In particular, special thanks go to (in roughly chronological order):
.PP
Bernie Cosell, Alan Young, Alex Satrapa, Mike Blazer, Wilbert van de Pieterman,
Steve Campbell, Robert Konigsberg, Scott Dellinger, R. Bernstein,
Daniel Winkelmann, Pires Claudio, Adrian Phillips,
Marek Rouchal, Luc St Louis, Adam Fischler, Kay RXpke, Matt Wilson,
Raviraj Murdeshwar and Slaven Rezic, Florian Pfaff
.PP
Geez, that's a lot of people. And apologies to the folks who were missed.
.PP
If you want someone to bug about this, that would be:
.PP
.Vb 1
\&    Shlomi Fish <shlomif@cpan.org>
.Ve
.PP
If you want more information, or want to participate, go to:
.PP
<http://sourceforge.net/projects/config\-inifiles/>
.PP
Please submit bug reports using the Request Tracker interface at
<https://rt.cpan.org/Public/Dist/Display.html?Name=Config\-IniFiles> .
.PP
Development discussion occurs on the mailing list
config\-inifiles\-dev@lists.sourceforge.net, which you can subscribe
to by going to the project web site (link above).
.SH "LICENSE"
.IX Header "LICENSE"
This software is copyright (c) 2000 by Scott Hutton and the rest of the
Config::IniFiles contributors.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
